/**
 * @generated
 */
module.exports = [
  {
    "path": "2018/11/11/how-to-choose-you-tech-stack.html",
    "content": "\n<figure name=\"2664\" id=\"2664\" class=\"graf graf--figure graf-after--h3\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"37\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*bQMdaHrbdFo2827cwqculw.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*bQMdaHrbdFo2827cwqculw.png)</noscript>\n\n</figure>\n\nSo, you’ve closed the deal for a big nice & challenging project. Or your company\nis building a number of internal new products and you got assigned the\nresponsibility to kickstart the product development phase.\n\n<!--truncate-->\n\nIf you’re starting the above stories, each time with a clean slate, then this\narticle might be of some help for you.\n\nIn this article we will go through how we have chosen a Technology Stack, and\nwhy we have decided to stick around for a while.\n\n#### Cost of project kickstart\n\nIf you’re a Microsoft fan-boy or RoR serial killer, then this might not be a big\ndeal for you. There is almost one known and recommended way, to start any\nproject. But if you live in the Javascript death Arena, just like us, then this\nmight be a pain in the \\*\\*\\* each time you’re starting a new project.\n\nWith Javascript’s extremely fragmented world, starting a new project from\nscratch is usually a nightmare. With endless amount of options, and new\nlibrary/framework being created every few minutes. There is an extremely high\nprobability that you have gone through analysis paralysis while you were\nselecting the stack for your new project. And you probably stayed for few weeks\nlike a kid in a candy store, while looking for your perfect tool.\n\n#### Our approach\n\nWell, we have been through that pain before, and unfortunately there is no way\nthat you wouldn’t go through it as long as you’ve chosen to go through\nJavascript (Which seems inevitable nowadays). The best you can do is sticking to\nan option (once you found a reasonable one), and stick to it for few years (2–3\nyears sounds reasonable).\n\nChoosing the Technology stack of choice is a black art though. There is not a\nsilver pullet here. But we’ll present our approach to do it.\n\nAfter choosing the Technology Stack, you’ll be faced by the challenge of how to\nreduce the cost of each new project you build with your chosen Technology Stack.\nWhich is subject of our next article in this series.\n\n#### Choosing a Technology Stack\n\nWe have gone through two steps iteratively to choose our stack. We used\niterative deepening approach, where we researched on surface till we chosen the\nmain direction. And after inspecting shallowly all directions, we went inside\neach direction for a more detailed research or prototyping. Eliminating some\nmain options as we go, and deciding to go further into others. Till we ended up\nwith 1 selected main technology, where we kept digging deeper to find the fine\ndetails of the big image. And so on. At the heart of that process, there have\nbeen always two main steps :\n\n\\*\\*Research Step :\n\n**Prototyping Step :  \n**This is not a completely separate step, rather we have gone through some\nreally quick experiments to validate our research finding. Either leading to\nmore research needed for an option. Or abandonment of an option. While doing\nthese prototypes, it’s important to keep your specific use case in mind. And try\nto make those prototypes close to your typical use case. For instance, are you\nusually working on highly interactive projects ? Is your main target mobile or\ndesktop ? Is the size of the tool’s binary or (bundle) is of big concern for\nyour company or usual target customer ? ….. etc.\n\n**Sounds Cool But ….  \n**You could spend forever in the above two steps going forward and backward, as\nwe said at the beginning, like a kid in a candy store. So, we decided the\nfollowing :\n\n1.  As long as, there are at least tens of thousands of developers are\n    recommending this technology and using it on daily basis. That means it’s\n    battle tested and production ready. And also means that, it’s a viable\n    option for us.\n2.  If we have done enough experiments and it seems like satisfying our main\n    expected use cases. Then again, it’s a viable option for us.\n\nFor any tool that satisfies the above two conditions, There is a very high\nprobability that we can’t go wrong by choosing it. So we decided to :\n\n1.  Time box the whole process.\n2.  When the time is up, choose whatever we felt right based on the heuristics\n    and experiments we did so far.\n3.  We know that we could never choose a “Perfect” stack for our cases. But\n    “Good Enough” is good enough.\n\nThis phase took us approximately 1.5 months. Till we landed our choice on a\nTechnology stack. The time was up before we explore all options available, in\ngreat details. But as we said, we believed that we’ve achieved was “Good\nEnough”. And “Good Enough” is good enough !\n\n#### Maximizing the gains\n\nI find it foolish and extremely anti-productive, to use a new technology for\neach new project (Or even for each few new projects). IMHO, I believe that\nyou’ve to stick to your chosen Technology stack for few years to reap the\nbenefits of accumulated know-how, and stand out in a crowd. For instance, there\nare overwhelmingly huge number of Angular Fan boys out there. The same for React\n& Vue.js. You can find them out there on the internet cursing at each others.\nBut, there aren’t as much real experts in any of these tech stacks. Since to\nmaster any stack, and be extremely productive, you have to spend few years with\nyour Technology. To build up on your know how about it’s weaknesses and how to\ntweak it’s performance. For instance, while going through articles, I’ve came\nacross endless number of people complaining about, how their Meteor App was\ncrushed under their first real production users’ wave. Well they were simply\nmostly newbies, who didn’t understand how Meteor works under the hood, and used\nall it’s neat features without understanding it’s weaknesses (Which are\nrelatively easy to guard against if you know what you’re looking for).\n\nNot only you should stick to one technology to understand it well. But most\nimportantly to be able to invest in your components’ and modules’ libraries as a\nseed for re-use. Such that the cost of each new project is substantially less\nthan the previous one.\n\nMy general advice here, is if a new technology is clearly (And everyone is\nsaying it) 5–10x, better than your chosen Tech. Stack. Then go for that new kid\nin the town. Otherwise, stick to what you have and keep reaping the benefits.\nWhen we say 10x better, that includes, how would it be easy to find/hire\ndevelopers who are willing to use it ? How much is it supported on client\nplatforms (Browsers & Mobiles … etc) ? Does it support modern devices’\ncapabilities ? Would you still be competitive in the market (For services\nfirms) ? And, obviously, does the new kid in the down is crushing it performance\nor productivity wise ?…..etc.\n\nAnother advice, is that, for any chosen Technology Stack, there would be that\nrosy promise at the beginning. Then once you’ve started to have few thousands of\nlines-of-code, you would most probably hit your first wall with performance\nissues. Then you might be faced with some productivity issues, then…., then …\netc. Well, in most cases, you shouldn’t panic and jump to a new Technology\nStack. Instead, stick around, try hard to fix your issues. They’re most probably\nfixable, and if it’s being used by giant companies, then they must be facing\nwhat you’re facing and much worse. Just spend sometime and fix your issues,\nsince the grass on the other side is always greener, and it would be always\nextremely tempting to jump to the other side.\n\nIn a following article we would talk more about our approach for Re-use, and how\nto make sure that each new project is a step forward, and that it’s cost for you\nis much less than the previous one.\n",
    "title": "How to choose you Technical Stack",
    "author": "Mostafa Elganainy",
    "authorURL": "https://www.facebook.com/mostafa.El.ganainy.2",
    "authorFBID": 648262785,
    "id": "How to choose you Technical Stack",
    "date": "2018-11-11T06:00:00.000Z",
    "seconds": 1541916000
  },
  {
    "path": "2018/11/11/design-for-re-use.html",
    "content": "\nThis is the second article in the series of our path toward Software Delivery\nefficiency. Reading article one, is recommended, but not necessary to follow up\nwith this one : Part I :\n[How To Choose Your Tech Stack](https://medium.com/react-badr/how-to-choose-you-tech-stack-97db78f8dc12)\n\n**So, again,** you’ve closed the deal for a big nice & challenging project. Or\nyour company is building a number of internal new products and you got assigned\nthe responsibility to kickstart the product development phase. **But,** this\ntime you’ve already chosen your tech. stack, and you’re familiar with the stack.\nAnd ready to hit the ground running.\n\n<!--truncate-->\n\nBut still, for each new project you start from scratch. Either that scratch\nmeans the scratch provided by the tool itself. i.e. create-react-app, or some\ntemplate you’ve built in-house, or some community built template. They’re all\nconsidered a scratch. If you’re starting from a similar scratch each time, then\nthis article might be for you.\n\n#### Background\n\nFor sometime, we have been doing the same, we had our own chosen tech. stack\nthat we’ve been using for years, and are familiar with it. But each new project\nseemed to include some un-necessary time waste, which was exactly like the\nprevious project. But since, the code isn’t designed for re-use, we found that\nit’s really hard to move the code around. Plus, some times, there are legal\nissues for doing so.\n\nSo, in this article we will explain our current approach to avoid these issues\nand design to tackle the Re-use problem.\n\nI’ll try to approach the topic from a generic point of view. Yet, at some\npoints, I would be giving examples from our own case, which is mainly a FE/BE\ncombination, with the FE based on React, and BE based on RoR, communicating\nthrough GraphQL interface.\n\nSo we follow the Atomic Design ideas for the UI part, and Pluggable/Modular\ndesign ideas to maximize the re-use in terms of features & higher level system\ncomponents.\n\n#### Architecture\n\nThe simple most popular Web Apps Pattern, MVC, won’t be sufficient to reach a\ngreat level of re-use. Since in it’s simplest form, it’s a flat\ndesign/structure. And in modern Web Applications, SPA became a defacto-standard,\nSo, the ‘View’ part of MVC, became extremely Fat. In fact, it became a whole\nseparate part of the story. So, the Backend in our case, is just a\n“Model/Controller” serving APIs for the Frontend. And the Frontend itself, is a\nfull blown project, with it’s own Architecture as well.\n\nThe first part of the solution, is to follow a modular design, where modules are\ncut at certain points. Both the FE & BE, need to have a the same corresponding\ncut points. The answer to : where exactly to design your cut points ? is simply\n“it depends” and is kind of a black art.\n\nSo large modules, will mean less re-usability, since the needs & requirements of\neach new project will be most probably completely different. And small modules\nmeans so much extra work. Since, the larger the total surface areas of all the\nmodules, the larger the maintenance and API management work is needed. These are\nalmost the same constraints/trade-offs you’ll face while designing any SOA\nsystem. (Or the sexier term, Micro-services based system).\n\nTo avoid going into this dilemma forever, we have designed our re-use framework\nas a hierarchical system. Starting at the bottom with the smallest part of the\nUI (A button, label….etc), and going up, in agglomerative fashion toward the top\nto compose bigger and bigger pieces of the puzzle.\n\nThe result is some sort of LEGO like architecture, where you have small building\nblocks, that’s almost useless on their own. But combing increasingly growing\npieces together will start to make sense. And thus you would have the choice\nlater, on what to re-use. Whether to re-use whole modules, or to go a level\ndown, and re-use large components, or going even lower and re-use tiny pieces.\n\nLet’s walk through the following journey, to see how to convert a monolith\nnon-reusable design to a little bit more reuse friendly design. Here we’re\ntaking the example of an eCommerce website, looking only at 3 Functional areas :\n\n1.  User Account Management (signup, login, …. etc)\n2.  Products (product listing, product cards, sorting, searching, filtering…\n    etc)\n3.  Orders (add to cart, view shopping cart, checkout…etc)\n\nNow let’s walk through a sample design.\n\n**Monolith App :**\n\n<figure name=\"f8c2\" id=\"f8c2\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"31\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*h8wqtpM20eftNK0MrhRX5g.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*h8wqtpM20eftNK0MrhRX5g.png)</noscript>\n\n</figure>\n\nThis is the most straightforward and common way to do SPAs. Maybe with different\ntechnologies the naming will be slightly different, but the general concept\n(Component vs. View), (Model vs. Controller)….etc. But the whole system is\nwritten in one big place.\n\nThe problem with this model is that it would grow rapidly into a giant mess.\nPlus for any medium sized Application, maintaining this would be a night mare.\n\nAlso if you’re following this model with new projects, like what we’ve used to\ndo. You’ll find yourself starting each new project from scratch as we’ve\nillustrated at the beginning. So, let’s look at the next possible solution.\n\n**Modular Design :**\n\n<figure name=\"9970\" id=\"9970\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"29\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*SQyPNxM3KNlLx-AziGCEiw.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*SQyPNxM3KNlLx-AziGCEiw.png)</noscript>\n\n</figure>\n\nfunctional scope. Which will reduce the messiness and maintainability issues of\nyour system.\n\nBut still, up till this point, you haven’t fixed the re-use problem. Since still\nthere is “no” common ground between the modules. We’ve just separated them into\nfolders. Plus, each new project, will most probably have completely different\nneeds. Which will make copying & pasting from module’s code a crazy shotgun\nprocess. Which you will also most likely not do.\n\n**Design For Re-use Step 1 (Cross cutting concerns)**\n\n<figure name=\"ce63\" id=\"ce63\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"33\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*XVfMXi96Z03_4JdTVD9qSg.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*XVfMXi96Z03_4JdTVD9qSg.png)</noscript>\n\n</figure>\n\nNow we’re talking !\n\nThis would be your first real step toward Re-use. In this approach, you extract\nall the cross-cutting concerns, like user session management, security, logging\n& communicating with the Backend … etc. Also, concerns like how modules\nintegrate with each other, and how to make them loosely coupled from each other,\npotentially by exporting module interfaces. All of these should be be\nachievable. If you have done a good job at this step, you will end up with the\nfirst pieces of your code base that could be extracted and used in other\nprojects later. Or even contributed as open source helpers/tools.\n\nThis is the first piece of your puzzle, and here you should write these things\nonce, and write it well. Try to think deeply about the surface areas of each\ncorss-cutting concern. It’s API, it’s limitations, how others could extend\nit ….etc. This is a kind of a black art, but as long as you’re following the\nconcept of single responsibility, where each one of these is only doing one job,\nand doing it right, you should be fine.\n\nThese cross-cutting concerns, should be as dry as possible. They should contain\nno logic that tightly related to one project. If you need customization for the\nproject that you’ll believe would be irrelevant to other projects, you should\nmake it as customizations on top of your generic library. Thus keeping your code\nlibrary clean and dry to the max.\n\nBut still, you’ve not solved the Re-use problem fully. Still each module has\npages which are built from the ground up specifically specific to this module.\nSo, let’s see the next step (Atomic Design)\n\n**Design For Re-use Step 2 (Atomic Design)**\n\n<figure name=\"304d\" id=\"304d\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"39\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*MXCPHjwkzUA_dG7fZHfuLg.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*MXCPHjwkzUA_dG7fZHfuLg.png)</noscript>\n\n</figure>\n\nBuilding on two advances in the SPAs community. 1\\. SPAs frameworks built around\ncomponents (Or embracing component based approach), and, 2\\. Atomic design.\n\nFirst, most modern SPAs frameworks comes with a built support for components.\nSome of which, take this to the extreme, where everything is a component. The\nwhole App, is comprised of components hierarchy. Most these frameworks would\npromote the concept of starting with the smallest possible component.\n\nSecond, atomic design, which is illustrated in depth in\n[this](http://bradfrost.com/blog/post/atomic-web-design/) article :\n\n<figure name=\"0b55\" id=\"0b55\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"21\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*J2q9cAs1jJZxkVG1EqtLfQ.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*J2q9cAs1jJZxkVG1EqtLfQ.png)</noscript>\n\n<figcaption class=\"imageCaption\">Image from : [http://bradfrost.com/blog/post/atomic-web-design/](http://bradfrost.com/blog/post/atomic-web-design/)</figcaption>\n\n</figure>\n\nthat resembles the organization found in nature :\n\n1.  Atoms : The most basic building blocks of nature elements. In our case, that\n    could be a Button, a Label, …..etc.\n2.  Molecules : Comprised of few atoms bonding together to make a somewhat more\n    advanced (And useful) building block. In our case, that could be a Search\n    box, Check box….etc\n3.  Organism : More advanced building block, comprised of several types of\n    Molecules combined together to make the first level of useful functionality.\n    For instance, the “Product Filtering Component” … etc.\n4.  Templates : Even one more level up, where whole parts of a page are combined\n    together, glueing together multiple Organisms. This could be the whole\n    “Product Listing Component”\n5.  Pages : Are a full page of the system with layout glueing together the\n    templates, or parts of the page.\n\n**Design For Re-use Step 3(Theming)**\n\n<figure name=\"9f4d\" id=\"9f4d\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"35\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*n7Bb2BdjGTvO4REUuKTyZA.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*n7Bb2BdjGTvO4REUuKTyZA.png)</noscript>\n\n</figure>\n\nIt’s almost always the case, that the theme of colors/sizes…etc, that you’ve\nused in one project, won’t fit into your next project. So, it’s crucial that\nyour atoms be easy to change colors and everything in an easy way. And also, the\nmore you can re-use atoms to build other atoms the faster you can grow your\nAtoms library. For example in the above image, we’ve used the same button, to\nbuild the select box. And all are sharing a number of general features.\n\n**Conclusion**\n\nThe current state of the main-stream technology makes it easier than ever to\ndesign for Re-use, and minimize the repetition with each new project you’re\nbuilding. And you should strategize this in your projects (If you haven’t\nalready).\n\nAlso, Depending on your case, you might have hard time asking your boss to let\nyou do this and rebuild his tech. stack, while he’s tight on deliveries and\ntimelines. What you would need to do in that case, is to first stop and think\nwhat’s the fastest gains and lowest hanging fruits that you can attack. And\nstart introducing these concepts slowly. You don’t even have to do them all at\nonce or in one project.\n\n**Where to go from here :**\n\n1.  Check our work-in-progress (Pre-alpha-release),\n    [here…](https://badrit.github.io/bractal/#/Atoms/Form%20Elements?id=button),\n    which is part of [Bractal](https://github.com/BadrIT/bractal) (Our\n    in-progress open source project, that implement the above concepts in React)\n2.  It worth mentioning that modules could be broken down into tiny pieces\n    according to [Micro-services design](https://microservices.io). But, unless\n    you have a good capable DevOps team, and you know exactly what you’re doing,\n    I don’t recommend starting a big production project with tiny\n    Micro-services.\n3.  Also, you can take the idea further, and do Micro-frontends :\n    [https://micro-frontends.org](https://micro-frontends.org)\n\n# Design for Re-use\n\nThis is the second article in the series of our path toward Software Delivery\nefficiency. Reading article one, is recommended, but not necessary to follow up\nwith this one : Part I :\n[How To Choose Your Tech Stack](https://medium.com/react-badr/how-to-choose-you-tech-stack-97db78f8dc12)\n\n**So, again,** you’ve closed the deal for a big nice & challenging project. Or\nyour company is building a number of internal new products and you got assigned\nthe responsibility to kickstart the product development phase. **But,** this\ntime you’ve already chosen your tech. stack, and you’re familiar with the stack.\nAnd ready to hit the ground running.\n\nBut still, for each new project you start from scratch. Either that scratch\nmeans the scratch provided by the tool itself. i.e. create-react-app, or some\ntemplate you’ve built in-house, or some community built template. They’re all\nconsidered a scratch. If you’re starting from a similar scratch each time, then\nthis article might be for you.\n\n#### Background\n\nFor sometime, we have been doing the same, we had our own chosen tech. stack\nthat we’ve been using for years, and are familiar with it. But each new project\nseemed to include some un-necessary time waste, which was exactly like the\nprevious project. But since, the code isn’t designed for re-use, we found that\nit’s really hard to move the code around. Plus, some times, there are legal\nissues for doing so.\n\nSo, in this article we will explain our current approach to avoid these issues\nand design to tackle the Re-use problem.\n\nI’ll try to approach the topic from a generic point of view. Yet, at some\npoints, I would be giving examples from our own case, which is mainly a FE/BE\ncombination, with the FE based on React, and BE based on RoR, communicating\nthrough GraphQL interface.\n\nSo we follow the Atomic Design ideas for the UI part, and Pluggable/Modular\ndesign ideas to maximize the re-use in terms of features & higher level system\ncomponents.\n\n#### Architecture\n\nThe simple most popular Web Apps Pattern, MVC, won’t be sufficient to reach a\ngreat level of re-use. Since in it’s simplest form, it’s a flat\ndesign/structure. And in modern Web Applications, SPA became a defacto-standard,\nSo, the ‘View’ part of MVC, became extremely Fat. In fact, it became a whole\nseparate part of the story. So, the Backend in our case, is just a\n“Model/Controller” serving APIs for the Frontend. And the Frontend itself, is a\nfull blown project, with it’s own Architecture as well.\n\nThe first part of the solution, is to follow a modular design, where modules are\ncut at certain points. Both the FE & BE, need to have a the same corresponding\ncut points. The answer to : where exactly to design your cut points ? is simply\n“it depends” and is kind of a black art.\n\nSo large modules, will mean less re-usability, since the needs & requirements of\neach new project will be most probably completely different. And small modules\nmeans so much extra work. Since, the larger the total surface areas of all the\nmodules, the larger the maintenance and API management work is needed. These are\nalmost the same constraints/trade-offs you’ll face while designing any SOA\nsystem. (Or the sexier term, Micro-services based system).\n\nTo avoid going into this dilemma forever, we have designed our re-use framework\nas a hierarchical system. Starting at the bottom with the smallest part of the\nUI (A button, label….etc), and going up, in agglomerative fashion toward the top\nto compose bigger and bigger pieces of the puzzle.\n\nThe result is some sort of LEGO like architecture, where you have small building\nblocks, that’s almost useless on their own. But combing increasingly growing\npieces together will start to make sense. And thus you would have the choice\nlater, on what to re-use. Whether to re-use whole modules, or to go a level\ndown, and re-use large components, or going even lower and re-use tiny pieces.\n\nLet’s walk through the following journey, to see how to convert a monolith\nnon-reusable design to a little bit more reuse friendly design. Here we’re\ntaking the example of an eCommerce website, looking only at 3 Functional areas :\n\n1.  User Account Management (signup, login, …. etc)\n2.  Products (product listing, product cards, sorting, searching, filtering…\n    etc)\n3.  Orders (add to cart, view shopping cart, checkout…etc)\n\nNow let’s walk through a sample design.\n\n**Monolith App :**\n\n<figure name=\"f8c2\" id=\"f8c2\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"31\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*h8wqtpM20eftNK0MrhRX5g.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*h8wqtpM20eftNK0MrhRX5g.png)</noscript>\n\n</figure>\n\nThis is the most straightforward and common way to do SPAs. Maybe with different\ntechnologies the naming will be slightly different, but the general concept\n(Component vs. View), (Model vs. Controller)….etc. But the whole system is\nwritten in one big place.\n\nThe problem with this model is that it would grow rapidly into a giant mess.\nPlus for any medium sized Application, maintaining this would be a night mare.\n\nAlso if you’re following this model with new projects, like what we’ve used to\ndo. You’ll find yourself starting each new project from scratch as we’ve\nillustrated at the beginning. So, let’s look at the next possible solution.\n\n**Modular Design :**\n\n<figure name=\"9970\" id=\"9970\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"29\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*SQyPNxM3KNlLx-AziGCEiw.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*SQyPNxM3KNlLx-AziGCEiw.png)</noscript>\n\n</figure>\n\nfunctional scope. Which will reduce the messiness and maintainability issues of\nyour system.\n\nBut still, up till this point, you haven’t fixed the re-use problem. Since still\nthere is “no” common ground between the modules. We’ve just separated them into\nfolders. Plus, each new project, will most probably have completely different\nneeds. Which will make copying & pasting from module’s code a crazy shotgun\nprocess. Which you will also most likely not do.\n\n**Design For Re-use Step 1 (Cross cutting concerns)**\n\n<figure name=\"ce63\" id=\"ce63\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"33\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*XVfMXi96Z03_4JdTVD9qSg.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*XVfMXi96Z03_4JdTVD9qSg.png)</noscript>\n\n</figure>\n\nNow we’re talking !\n\nThis would be your first real step toward Re-use. In this approach, you extract\nall the cross-cutting concerns, like user session management, security, logging\n& communicating with the Backend … etc. Also, concerns like how modules\nintegrate with each other, and how to make them loosely coupled from each other,\npotentially by exporting module interfaces. All of these should be be\nachievable. If you have done a good job at this step, you will end up with the\nfirst pieces of your code base that could be extracted and used in other\nprojects later. Or even contributed as open source helpers/tools.\n\nThis is the first piece of your puzzle, and here you should write these things\nonce, and write it well. Try to think deeply about the surface areas of each\ncorss-cutting concern. It’s API, it’s limitations, how others could extend\nit ….etc. This is a kind of a black art, but as long as you’re following the\nconcept of single responsibility, where each one of these is only doing one job,\nand doing it right, you should be fine.\n\nThese cross-cutting concerns, should be as dry as possible. They should contain\nno logic that tightly related to one project. If you need customization for the\nproject that you’ll believe would be irrelevant to other projects, you should\nmake it as customizations on top of your generic library. Thus keeping your code\nlibrary clean and dry to the max.\n\nBut still, you’ve not solved the Re-use problem fully. Still each module has\npages which are built from the ground up specifically specific to this module.\nSo, let’s see the next step (Atomic Design)\n\n**Design For Re-use Step 2 (Atomic Design)**\n\n<figure name=\"304d\" id=\"304d\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"39\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*MXCPHjwkzUA_dG7fZHfuLg.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*MXCPHjwkzUA_dG7fZHfuLg.png)</noscript>\n\n</figure>\n\nBuilding on two advances in the SPAs community. 1\\. SPAs frameworks built around\ncomponents (Or embracing component based approach), and, 2\\. Atomic design.\n\nFirst, most modern SPAs frameworks comes with a built support for components.\nSome of which, take this to the extreme, where everything is a component. The\nwhole App, is comprised of components hierarchy. Most these frameworks would\npromote the concept of starting with the smallest possible component.\n\nSecond, atomic design, which is illustrated in depth in\n[this](http://bradfrost.com/blog/post/atomic-web-design/) article :\n\n<figure name=\"0b55\" id=\"0b55\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"21\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*J2q9cAs1jJZxkVG1EqtLfQ.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*J2q9cAs1jJZxkVG1EqtLfQ.png)</noscript>\n\n<figcaption class=\"imageCaption\">Image from : [http://bradfrost.com/blog/post/atomic-web-design/](http://bradfrost.com/blog/post/atomic-web-design/)</figcaption>\n\n</figure>\n\nthat resembles the organization found in nature :\n\n1.  Atoms : The most basic building blocks of nature elements. In our case, that\n    could be a Button, a Label, …..etc.\n2.  Molecules : Comprised of few atoms bonding together to make a somewhat more\n    advanced (And useful) building block. In our case, that could be a Search\n    box, Check box….etc\n3.  Organism : More advanced building block, comprised of several types of\n    Molecules combined together to make the first level of useful functionality.\n    For instance, the “Product Filtering Component” … etc.\n4.  Templates : Even one more level up, where whole parts of a page are combined\n    together, glueing together multiple Organisms. This could be the whole\n    “Product Listing Component”\n5.  Pages : Are a full page of the system with layout glueing together the\n    templates, or parts of the page.\n\n**Design For Re-use Step 3(Theming)**\n\n<figure name=\"9f4d\" id=\"9f4d\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"35\"></canvas>\n\n![](https://cdn-images-1.medium.com/max/1000/1*n7Bb2BdjGTvO4REUuKTyZA.png)\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/1000/1*n7Bb2BdjGTvO4REUuKTyZA.png)</noscript>\n\n</figure>\n\nIt’s almost always the case, that the theme of colors/sizes…etc, that you’ve\nused in one project, won’t fit into your next project. So, it’s crucial that\nyour atoms be easy to change colors and everything in an easy way. And also, the\nmore you can re-use atoms to build other atoms the faster you can grow your\nAtoms library. For example in the above image, we’ve used the same button, to\nbuild the select box. And all are sharing a number of general features.\n\n**Conclusion**\n\nThe current state of the main-stream technology makes it easier than ever to\ndesign for Re-use, and minimize the repetition with each new project you’re\nbuilding. And you should strategize this in your projects (If you haven’t\nalready).\n\nAlso, Depending on your case, you might have hard time asking your boss to let\nyou do this and rebuild his tech. stack, while he’s tight on deliveries and\ntimelines. What you would need to do in that case, is to first stop and think\nwhat’s the fastest gains and lowest hanging fruits that you can attack. And\nstart introducing these concepts slowly. You don’t even have to do them all at\nonce or in one project.\n\n**Where to go from here :**\n\n1.  Check our work-in-progress (Pre-alpha-release),\n    [here…](https://badrit.github.io/bractal/#/Atoms/Form%20Elements?id=button),\n    which is part of [Bractal](https://github.com/BadrIT/bractal) (Our\n    in-progress open source project, that implement the above concepts in React)\n2.  It worth mentioning that modules could be broken down into tiny pieces\n    according to [Micro-services design](https://microservices.io). But, unless\n    you have a good capable DevOps team, and you know exactly what you’re doing,\n    I don’t recommend starting a big production project with tiny\n    Micro-services.\n3.  Also, you can take the idea further, and do Micro-frontends :\n    [https://micro-frontends.org](https://micro-frontends.org)\n",
    "title": "Design for Re-use",
    "author": "Mostafa Elganainy",
    "authorURL": "https://www.facebook.com/mostafa.El.ganainy.2",
    "authorFBID": 648262785,
    "id": "Design for Re-use",
    "date": "2018-11-11T06:00:00.000Z",
    "seconds": 1541916000
  },
  {
    "path": "2018/11/07/non-blocking-git-flow.html",
    "content": "\nWe’re following a slightly modified version of the popular gitflow approach.\n\n#### **Background**\n\nWe use a code review process, based on a merge/pull requests feature supported\nby gitlab/github where a feature will be reviewed based on a merged request from\nthe feature branch to the develop branch. Which is a cool and easy approach to\ndo code reviews. Where reviewer and feature author keep discussing the comments\nand see the changes revisions till the feature is accepted and thus merged into\nthe develop branch by the reviewer. Also the diffs and all merge details will\nstay there forever for reference purposes, even if the source branch\n(feature-branch) is deleted.\n\n<!--truncate-->\n\n#### **Why didn’t the standard approach work ?**\n\nWell, let’s first look at our case/constraints :\n\n1.  Our features are on average 3 weeks worth of work.\n2.  Reviewers are reviewing the code with SLA policy of 1 business day. Which\n    means a feature/task developed by noon of one day, might be reviewed by the\n    noon of the next day.\n3.  Our internal policy, states that no merge request should exceed 400 LOC,\n    while an average sized feature will be in range of 1000–2000 LOC.\n4.  Tasks within the same features are usually inter-dependent, which means to\n    start a new task, it’s usually far better to have the code of all the\n    previous tasks of the same feature.\n5.  We found no decent built-in way in gitlab/github, to support non-blocking\n    merge requests. Where author of the feature can merge his work into the\n    target branch directly, and reviewer still have the ability to review the\n    work and see merge history. The problem occurs when the branching/merging\n    history is lost and completely messed up, if the author merged his branch\n    into the develop branch before the merge request is closed.\n\nThe above constraints are near to impossible to be satisfied all at the same\ntime without some corners being cut. For example :\n\n1.  The author of the feature will need to wait for the reviewer to give him\n    comments (up to 24 hours), to avoid submitting code to the feature branch\n    (Which is being reviewed).\n2.  If reviewers let go of the SLA policy, they would suffer from severe context\n    switching which will leave them with zero productivity at the end of the\n    day. Since our reviewers are mostly Tech. Leads. Who will be reviewing the\n    code for several Engineers.\n\nSo, we tried a solution (Which seems like a working solution till now), which is\ndetailed in the following section…\n\n#### Non-blocking Git-flow\n\nOur model simply depends on feature branches which have a little long life span\n(2–4 weeks). With smaller tasks branches, going out and back into the feature\nbranch itself, rather than directly into the master branch. Those tasks are any\nkind of tasks related to a given feature. i.e. bug fixes, enhancements,\nsub-tasks, spikes …. etc. The Model will look like the following :\n\n<figure name=\"6a00\" id=\"6a00\" class=\"graf graf--figure graf-after--p\">\n\n<canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"75\"></canvas>\n\n<noscript class=\"js-progressiveMedia-inner\">![](https://cdn-images-1.medium.com/max/720/1*R-0Kg_wvxXqiuUPtsR7lqg.png)</noscript>\n\n</figure>\n\n_Note : (We excluded the rest of the standard gitflow model to keep the diagram\nsimple. Otherwise, in the diagram above, there would have been some more details\nrelated to release-branches, hotfixes & master branch)_\n\nAs you see in the above process, we have sacrificed a neat feature provided by\ngithub/gitlab. Which is showing the history of changes between different\nversions of the merge. The gain from losing that feature is the ability to have\na non-blocking code review process.\n\nThe price that has to be paid here, is the little inconvenience on the behalf of\nthe reviewer. Since, the reviewer will not have easy to access linking between\nthe _review-comments-fixes-branch_, and the original _task-branch_. He might\nneed to open two tabs in the browser and do check both at the same time.\n\nFor us, till now, this looks like the least price we can pay and satisfy our\nconstraints. You’re welcome to share your thoughts either on how you’re solving\nthis problem in your projects, or what you think we could do better…\n",
    "title": "Non-blocking Git-flow",
    "author": "Mostafa Elganainy",
    "authorURL": "https://www.facebook.com/mostafa.El.ganainy.2",
    "authorFBID": 648262785,
    "id": "Non-blocking Git-flow",
    "date": "2018-11-07T06:00:00.000Z",
    "seconds": 1541570400
  }
];
